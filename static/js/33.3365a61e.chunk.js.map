{"version":3,"sources":["../node_modules/@ionic/core/dist/esm/ion-route_4.entry.js","../node_modules/@ionic/core/dist/esm/theme-ff3fc52f.js"],"names":["Route","hostRef","registerInstance","this","ionRouteDataChanged","createEvent","url","newValue","emit","oldValue","keys1","Object","keys","keys2","length","key","onUpdate","RouteRedirect","ionRouteRedirectChanged","generatePath","segments","filter","s","join","chainToPath","chain","path","route","segment","param","params","slice","push","parsePath","split","map","trim","printRoutes","routes","console","group","forEach","r","ids","id","debug","groupEnd","printRedirects","redirects","redirect","to","from","writeNavState","root","direction","index","a","changed","animation","outlet","searchNavNode","componentOnReady","setRouteId","result","element","markVisible","error","readNavState","node","getRouteId","undefined","QUERY","matches","querySelector","routeRedirect","find","input","i","expected","matchesRedirect","matchesIDs","len","Math","min","toLowerCase","matchesPath","inputPath","allparams","RouterSegments","matchesDefault","data","next","mergeParams","b","assign","routerIDsToChain","chains","match","maxMatches","plainIDs","score","routerPathToChain","matchedChain","computePriority","level","pow","shift","readRedirects","Array","children","el","tagName","readProp","readRoutes","flattenRouterTree","readRouteNodes","component","Error","componentProps","beforeLeave","beforeEnter","prop","hasAttribute","getAttribute","nodes","flattenNode","Router","ionRouteWillChange","ionRouteDidChange","previousPath","busy","state","lastState","useHash","document","body","Promise","resolve","window","addEventListener","once","onRoutesChanged","debounce","onRedirectChanged","bind","historyDirection","getPath","runGuards","canProceed","writeNavStateRoot","ev","detail","register","processNextHandler","back","startsWith","URL","location","href","pathname","queryString","setPath","history","waitPromise","warn","safeWriteNavState","win","replaceState","title","redirectFrom","lock","unlock","p","toChain","fromChain","beforeEnterHook","beforeLeaveHook","canLeave","canEnter","routeEvent","routeChangeEvent","pushState","writePath","loc","hash","prefix","removePrefix","readPath","redirectFromPath","redirectedFrom","getElement","RouterLink","routerDirection","onClick","openURL","routerAnimation","mode","getIonMode","attrs","rel","target","h","Host","class","createColorClasses","color","style","hostContext","selector","closest","cssClassMap","getClassMap","classes","isArray","c","getClassList","SCHEME","test","router","preventDefault"],"mappings":"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","file":"static/js/33.3365a61e.chunk.js","sourcesContent":["import { r as registerInstance, e as createEvent, i as getElement, h, H as Host } from './index-e806d1f6.js';\nimport { b as getIonMode } from './ionic-global-9d5c8ee3.js';\nimport { k as debounce } from './helpers-002e4980.js';\nimport { o as openURL, c as createColorClasses } from './theme-ff3fc52f.js';\n\nconst Route = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.ionRouteDataChanged = createEvent(this, \"ionRouteDataChanged\", 7);\n    /**\n     * Relative path that needs to match in order for this route to apply.\n     *\n     * Accepts paths similar to expressjs so that you can define parameters\n     * in the url /foo/:bar where bar would be available in incoming props.\n     */\n    this.url = '';\n  }\n  onUpdate(newValue) {\n    this.ionRouteDataChanged.emit(newValue);\n  }\n  onComponentProps(newValue, oldValue) {\n    if (newValue === oldValue) {\n      return;\n    }\n    const keys1 = newValue ? Object.keys(newValue) : [];\n    const keys2 = oldValue ? Object.keys(oldValue) : [];\n    if (keys1.length !== keys2.length) {\n      this.onUpdate(newValue);\n      return;\n    }\n    for (const key of keys1) {\n      if (newValue[key] !== oldValue[key]) {\n        this.onUpdate(newValue);\n        return;\n      }\n    }\n  }\n  connectedCallback() {\n    this.ionRouteDataChanged.emit();\n  }\n  static get watchers() { return {\n    \"url\": [\"onUpdate\"],\n    \"component\": [\"onUpdate\"],\n    \"componentProps\": [\"onComponentProps\"]\n  }; }\n};\n\nconst RouteRedirect = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.ionRouteRedirectChanged = createEvent(this, \"ionRouteRedirectChanged\", 7);\n  }\n  propDidChange() {\n    this.ionRouteRedirectChanged.emit();\n  }\n  connectedCallback() {\n    this.ionRouteRedirectChanged.emit();\n  }\n  static get watchers() { return {\n    \"from\": [\"propDidChange\"],\n    \"to\": [\"propDidChange\"]\n  }; }\n};\n\nconst ROUTER_INTENT_NONE = 'root';\nconst ROUTER_INTENT_FORWARD = 'forward';\nconst ROUTER_INTENT_BACK = 'back';\n\nconst generatePath = (segments) => {\n  const path = segments\n    .filter(s => s.length > 0)\n    .join('/');\n  return '/' + path;\n};\nconst chainToPath = (chain) => {\n  const path = [];\n  for (const route of chain) {\n    for (const segment of route.path) {\n      if (segment[0] === ':') {\n        const param = route.params && route.params[segment.slice(1)];\n        if (!param) {\n          return null;\n        }\n        path.push(param);\n      }\n      else if (segment !== '') {\n        path.push(segment);\n      }\n    }\n  }\n  return path;\n};\nconst writePath = (history, root, useHash, path, direction, state, queryString) => {\n  let url = generatePath([\n    ...parsePath(root),\n    ...path\n  ]);\n  if (useHash) {\n    url = '#' + url;\n  }\n  if (queryString !== undefined) {\n    url = url + '?' + queryString;\n  }\n  if (direction === ROUTER_INTENT_FORWARD) {\n    history.pushState(state, '', url);\n  }\n  else {\n    history.replaceState(state, '', url);\n  }\n};\nconst removePrefix = (prefix, path) => {\n  if (prefix.length > path.length) {\n    return null;\n  }\n  if (prefix.length <= 1 && prefix[0] === '') {\n    return path;\n  }\n  for (let i = 0; i < prefix.length; i++) {\n    if (prefix[i].length > 0 && prefix[i] !== path[i]) {\n      return null;\n    }\n  }\n  if (path.length === prefix.length) {\n    return [''];\n  }\n  return path.slice(prefix.length);\n};\nconst readPath = (loc, root, useHash) => {\n  let pathname = loc.pathname;\n  if (useHash) {\n    const hash = loc.hash;\n    pathname = (hash[0] === '#')\n      ? hash.slice(1)\n      : '';\n  }\n  const prefix = parsePath(root);\n  const path = parsePath(pathname);\n  return removePrefix(prefix, path);\n};\nconst parsePath = (path) => {\n  if (path == null) {\n    return [''];\n  }\n  const removeQueryString = path.split('?')[0];\n  const segments = removeQueryString.split('/')\n    .map(s => s.trim())\n    .filter(s => s.length > 0);\n  if (segments.length === 0) {\n    return [''];\n  }\n  else {\n    return segments;\n  }\n};\n\nconst printRoutes = (routes) => {\n  console.group(`[ion-core] ROUTES[${routes.length}]`);\n  for (const chain of routes) {\n    const path = [];\n    chain.forEach(r => path.push(...r.path));\n    const ids = chain.map(r => r.id);\n    console.debug(`%c ${generatePath(path)}`, 'font-weight: bold; padding-left: 20px', '=>\\t', `(${ids.join(', ')})`);\n  }\n  console.groupEnd();\n};\nconst printRedirects = (redirects) => {\n  console.group(`[ion-core] REDIRECTS[${redirects.length}]`);\n  for (const redirect of redirects) {\n    if (redirect.to) {\n      console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to)}`, 'font-weight: bold');\n    }\n  }\n  console.groupEnd();\n};\n\nconst writeNavState = async (root, chain, direction, index, changed = false, animation) => {\n  try {\n    // find next navigation outlet in the DOM\n    const outlet = searchNavNode(root);\n    // make sure we can continue interacting the DOM, otherwise abort\n    if (index >= chain.length || !outlet) {\n      return changed;\n    }\n    await outlet.componentOnReady();\n    const route = chain[index];\n    const result = await outlet.setRouteId(route.id, route.params, direction, animation);\n    // if the outlet changed the page, reset navigation to neutral (no direction)\n    // this means nested outlets will not animate\n    if (result.changed) {\n      direction = ROUTER_INTENT_NONE;\n      changed = true;\n    }\n    // recursively set nested outlets\n    changed = await writeNavState(result.element, chain, direction, index + 1, changed, animation);\n    // once all nested outlets are visible let's make the parent visible too,\n    // using markVisible prevents flickering\n    if (result.markVisible) {\n      await result.markVisible();\n    }\n    return changed;\n  }\n  catch (e) {\n    console.error(e);\n    return false;\n  }\n};\nconst readNavState = async (root) => {\n  const ids = [];\n  let outlet;\n  let node = root;\n  // tslint:disable-next-line:no-constant-condition\n  while (true) {\n    outlet = searchNavNode(node);\n    if (outlet) {\n      const id = await outlet.getRouteId();\n      if (id) {\n        node = id.element;\n        id.element = undefined;\n        ids.push(id);\n      }\n      else {\n        break;\n      }\n    }\n    else {\n      break;\n    }\n  }\n  return { ids, outlet };\n};\nconst waitUntilNavNode = () => {\n  if (searchNavNode(document.body)) {\n    return Promise.resolve();\n  }\n  return new Promise(resolve => {\n    window.addEventListener('ionNavWillLoad', resolve, { once: true });\n  });\n};\nconst QUERY = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\nconst searchNavNode = (root) => {\n  if (!root) {\n    return undefined;\n  }\n  if (root.matches(QUERY)) {\n    return root;\n  }\n  const outlet = root.querySelector(QUERY);\n  return outlet ? outlet : undefined;\n};\n\nconst matchesRedirect = (input, route) => {\n  const { from, to } = route;\n  if (to === undefined) {\n    return false;\n  }\n  if (from.length > input.length) {\n    return false;\n  }\n  for (let i = 0; i < from.length; i++) {\n    const expected = from[i];\n    if (expected === '*') {\n      return true;\n    }\n    if (expected !== input[i]) {\n      return false;\n    }\n  }\n  return from.length === input.length;\n};\nconst routeRedirect = (path, routes) => {\n  return routes.find(route => matchesRedirect(path, route));\n};\nconst matchesIDs = (ids, chain) => {\n  const len = Math.min(ids.length, chain.length);\n  let i = 0;\n  for (; i < len; i++) {\n    if (ids[i].toLowerCase() !== chain[i].id) {\n      break;\n    }\n  }\n  return i;\n};\nconst matchesPath = (inputPath, chain) => {\n  const segments = new RouterSegments(inputPath);\n  let matchesDefault = false;\n  let allparams;\n  for (let i = 0; i < chain.length; i++) {\n    const path = chain[i].path;\n    if (path[0] === '') {\n      matchesDefault = true;\n    }\n    else {\n      for (const segment of path) {\n        const data = segments.next();\n        // data param\n        if (segment[0] === ':') {\n          if (data === '') {\n            return null;\n          }\n          allparams = allparams || [];\n          const params = allparams[i] || (allparams[i] = {});\n          params[segment.slice(1)] = data;\n        }\n        else if (data !== segment) {\n          return null;\n        }\n      }\n      matchesDefault = false;\n    }\n  }\n  const matches = (matchesDefault)\n    ? matchesDefault === (segments.next() === '')\n    : true;\n  if (!matches) {\n    return null;\n  }\n  if (allparams) {\n    return chain.map((route, i) => ({\n      id: route.id,\n      path: route.path,\n      params: mergeParams(route.params, allparams[i])\n    }));\n  }\n  return chain;\n};\nconst mergeParams = (a, b) => {\n  if (!a && b) {\n    return b;\n  }\n  else if (a && !b) {\n    return a;\n  }\n  else if (a && b) {\n    return Object.assign(Object.assign({}, a), b);\n  }\n  return undefined;\n};\nconst routerIDsToChain = (ids, chains) => {\n  let match = null;\n  let maxMatches = 0;\n  const plainIDs = ids.map(i => i.id);\n  for (const chain of chains) {\n    const score = matchesIDs(plainIDs, chain);\n    if (score > maxMatches) {\n      match = chain;\n      maxMatches = score;\n    }\n  }\n  if (match) {\n    return match.map((route, i) => ({\n      id: route.id,\n      path: route.path,\n      params: mergeParams(route.params, ids[i] && ids[i].params)\n    }));\n  }\n  return null;\n};\nconst routerPathToChain = (path, chains) => {\n  let match = null;\n  let matches = 0;\n  for (const chain of chains) {\n    const matchedChain = matchesPath(path, chain);\n    if (matchedChain !== null) {\n      const score = computePriority(matchedChain);\n      if (score > matches) {\n        matches = score;\n        match = matchedChain;\n      }\n    }\n  }\n  return match;\n};\nconst computePriority = (chain) => {\n  let score = 1;\n  let level = 1;\n  for (const route of chain) {\n    for (const path of route.path) {\n      if (path[0] === ':') {\n        score += Math.pow(1, level);\n      }\n      else if (path !== '') {\n        score += Math.pow(2, level);\n      }\n      level++;\n    }\n  }\n  return score;\n};\nclass RouterSegments {\n  constructor(path) {\n    this.path = path.slice();\n  }\n  next() {\n    if (this.path.length > 0) {\n      return this.path.shift();\n    }\n    return '';\n  }\n}\n\nconst readRedirects = (root) => {\n  return Array.from(root.children)\n    .filter(el => el.tagName === 'ION-ROUTE-REDIRECT')\n    .map(el => {\n    const to = readProp(el, 'to');\n    return {\n      from: parsePath(readProp(el, 'from')),\n      to: to == null ? undefined : parsePath(to),\n    };\n  });\n};\nconst readRoutes = (root) => {\n  return flattenRouterTree(readRouteNodes(root));\n};\nconst readRouteNodes = (root, node = root) => {\n  return Array.from(node.children)\n    .filter(el => el.tagName === 'ION-ROUTE' && el.component)\n    .map(el => {\n    const component = readProp(el, 'component');\n    if (component == null) {\n      throw new Error('component missing in ion-route');\n    }\n    return {\n      path: parsePath(readProp(el, 'url')),\n      id: component.toLowerCase(),\n      params: el.componentProps,\n      beforeLeave: el.beforeLeave,\n      beforeEnter: el.beforeEnter,\n      children: readRouteNodes(root, el)\n    };\n  });\n};\nconst readProp = (el, prop) => {\n  if (prop in el) {\n    return el[prop];\n  }\n  if (el.hasAttribute(prop)) {\n    return el.getAttribute(prop);\n  }\n  return null;\n};\nconst flattenRouterTree = (nodes) => {\n  const routes = [];\n  for (const node of nodes) {\n    flattenNode([], routes, node);\n  }\n  return routes;\n};\nconst flattenNode = (chain, routes, node) => {\n  const s = chain.slice();\n  s.push({\n    id: node.id,\n    path: node.path,\n    params: node.params,\n    beforeLeave: node.beforeLeave,\n    beforeEnter: node.beforeEnter\n  });\n  if (node.children.length === 0) {\n    routes.push(s);\n    return;\n  }\n  for (const sub of node.children) {\n    flattenNode(s, routes, sub);\n  }\n};\n\nconst Router = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.ionRouteWillChange = createEvent(this, \"ionRouteWillChange\", 7);\n    this.ionRouteDidChange = createEvent(this, \"ionRouteDidChange\", 7);\n    this.previousPath = null;\n    this.busy = false;\n    this.state = 0;\n    this.lastState = 0;\n    /**\n     * By default `ion-router` will match the routes at the root path (\"/\").\n     * That can be changed when\n     *\n     */\n    this.root = '/';\n    /**\n     * The router can work in two \"modes\":\n     * - With hash: `/index.html#/path/to/page`\n     * - Without hash: `/path/to/page`\n     *\n     * Using one or another might depend in the requirements of your app and/or where it's deployed.\n     *\n     * Usually \"hash-less\" navigation works better for SEO and it's more user friendly too, but it might\n     * requires additional server-side configuration in order to properly work.\n     *\n     * On the otherside hash-navigation is much easier to deploy, it even works over the file protocol.\n     *\n     * By default, this property is `true`, change to `false` to allow hash-less URLs.\n     */\n    this.useHash = true;\n  }\n  async componentWillLoad() {\n    console.debug('[ion-router] router will load');\n    await waitUntilNavNode();\n    console.debug('[ion-router] found nav');\n    await this.onRoutesChanged();\n  }\n  componentDidLoad() {\n    window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\n    window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\n  }\n  async onPopState() {\n    const direction = this.historyDirection();\n    let path = this.getPath();\n    const canProceed = await this.runGuards(path);\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        path = parsePath(canProceed.redirect);\n      }\n      return false;\n    }\n    console.debug('[ion-router] URL changed -> update nav', path, direction);\n    return this.writeNavStateRoot(path, direction);\n  }\n  onBackButton(ev) {\n    ev.detail.register(0, processNextHandler => {\n      this.back();\n      processNextHandler();\n    });\n  }\n  /** @internal */\n  async canTransition() {\n    const canProceed = await this.runGuards();\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        return canProceed.redirect;\n      }\n      else {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Navigate to the specified URL.\n   *\n   * @param url The url to navigate to.\n   * @param direction The direction of the animation. Defaults to `\"forward\"`.\n   */\n  async push(url, direction = 'forward', animation) {\n    if (url.startsWith('.')) {\n      url = (new URL(url, window.location.href)).pathname;\n    }\n    console.debug('[ion-router] URL pushed -> updating nav', url, direction);\n    let path = parsePath(url);\n    let queryString = url.split('?')[1];\n    const canProceed = await this.runGuards(path);\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        path = parsePath(canProceed.redirect);\n        queryString = canProceed.redirect.split('?')[1];\n      }\n      else {\n        return false;\n      }\n    }\n    this.setPath(path, direction, queryString);\n    return this.writeNavStateRoot(path, direction, animation);\n  }\n  /**\n   * Go back to previous page in the window.history.\n   */\n  back() {\n    window.history.back();\n    return Promise.resolve(this.waitPromise);\n  }\n  /** @internal */\n  async printDebug() {\n    console.debug('CURRENT PATH', this.getPath());\n    console.debug('PREVIOUS PATH', this.previousPath);\n    printRoutes(readRoutes(this.el));\n    printRedirects(readRedirects(this.el));\n  }\n  /** @internal */\n  async navChanged(direction) {\n    if (this.busy) {\n      console.warn('[ion-router] router is busy, navChanged was cancelled');\n      return false;\n    }\n    const { ids, outlet } = await readNavState(window.document.body);\n    const routes = readRoutes(this.el);\n    const chain = routerIDsToChain(ids, routes);\n    if (!chain) {\n      console.warn('[ion-router] no matching URL for ', ids.map(i => i.id));\n      return false;\n    }\n    const path = chainToPath(chain);\n    if (!path) {\n      console.warn('[ion-router] router could not match path because some required param is missing');\n      return false;\n    }\n    console.debug('[ion-router] nav changed -> update URL', ids, path);\n    this.setPath(path, direction);\n    await this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, path, null, ids.length);\n    return true;\n  }\n  onRedirectChanged() {\n    const path = this.getPath();\n    if (path && routeRedirect(path, readRedirects(this.el))) {\n      this.writeNavStateRoot(path, ROUTER_INTENT_NONE);\n    }\n  }\n  onRoutesChanged() {\n    return this.writeNavStateRoot(this.getPath(), ROUTER_INTENT_NONE);\n  }\n  historyDirection() {\n    const win = window;\n    if (win.history.state === null) {\n      this.state++;\n      win.history.replaceState(this.state, win.document.title, win.document.location && win.document.location.href);\n    }\n    const state = win.history.state;\n    const lastState = this.lastState;\n    this.lastState = state;\n    if (state > lastState || (state >= lastState && lastState > 0)) {\n      return ROUTER_INTENT_FORWARD;\n    }\n    else if (state < lastState) {\n      return ROUTER_INTENT_BACK;\n    }\n    else {\n      return ROUTER_INTENT_NONE;\n    }\n  }\n  async writeNavStateRoot(path, direction, animation) {\n    if (!path) {\n      console.error('[ion-router] URL is not part of the routing set');\n      return false;\n    }\n    // lookup redirect rule\n    const redirects = readRedirects(this.el);\n    const redirect = routeRedirect(path, redirects);\n    let redirectFrom = null;\n    if (redirect) {\n      this.setPath(redirect.to, direction);\n      redirectFrom = redirect.from;\n      path = redirect.to;\n    }\n    // lookup route chain\n    const routes = readRoutes(this.el);\n    const chain = routerPathToChain(path, routes);\n    if (!chain) {\n      console.error('[ion-router] the path does not match any route');\n      return false;\n    }\n    // write DOM give\n    return this.safeWriteNavState(document.body, chain, direction, path, redirectFrom, 0, animation);\n  }\n  async safeWriteNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.writeNavState(node, chain, direction, path, redirectFrom, index, animation);\n    }\n    catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise(r => resolve = r);\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  async runGuards(to = this.getPath(), from = parsePath(this.previousPath)) {\n    if (!to || !from) {\n      return true;\n    }\n    const routes = readRoutes(this.el);\n    const toChain = routerPathToChain(to, routes);\n    const fromChain = routerPathToChain(from, routes);\n    const beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;\n    const beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;\n    const canLeave = beforeLeaveHook ? await beforeLeaveHook() : true;\n    if (canLeave === false || typeof canLeave === 'object') {\n      return canLeave;\n    }\n    const canEnter = beforeEnterHook ? await beforeEnterHook() : true;\n    if (canEnter === false || typeof canEnter === 'object') {\n      return canEnter;\n    }\n    return true;\n  }\n  async writeNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {\n    if (this.busy) {\n      console.warn('[ion-router] router is busy, transition was cancelled');\n      return false;\n    }\n    this.busy = true;\n    // generate route event and emit will change\n    const routeEvent = this.routeChangeEvent(path, redirectFrom);\n    if (routeEvent) {\n      this.ionRouteWillChange.emit(routeEvent);\n    }\n    const changed = await writeNavState(node, chain, direction, index, false, animation);\n    this.busy = false;\n    if (changed) {\n      console.debug('[ion-router] route changed', path);\n    }\n    // emit did change\n    if (routeEvent) {\n      this.ionRouteDidChange.emit(routeEvent);\n    }\n    return changed;\n  }\n  setPath(path, direction, queryString) {\n    this.state++;\n    writePath(window.history, this.root, this.useHash, path, direction, this.state, queryString);\n  }\n  getPath() {\n    return readPath(window.location, this.root, this.useHash);\n  }\n  routeChangeEvent(path, redirectFromPath) {\n    const from = this.previousPath;\n    const to = generatePath(path);\n    this.previousPath = to;\n    if (to === from) {\n      return null;\n    }\n    const redirectedFrom = redirectFromPath ? generatePath(redirectFromPath) : null;\n    return {\n      from,\n      redirectedFrom,\n      to,\n    };\n  }\n  get el() { return getElement(this); }\n};\n\nconst routerLinkCss = \":host{--background:transparent;--color:var(--ion-color-primary, #3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}\";\n\nconst RouterLink = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * When using a router, it specifies the transition direction when navigating to\n     * another page using `href`.\n     */\n    this.routerDirection = 'forward';\n    this.onClick = (ev) => {\n      openURL(this.href, ev, this.routerDirection, this.routerAnimation);\n    };\n  }\n  render() {\n    const mode = getIonMode(this);\n    const attrs = {\n      href: this.href,\n      rel: this.rel,\n      target: this.target\n    };\n    return (h(Host, { onClick: this.onClick, class: createColorClasses(this.color, {\n        [mode]: true,\n        'ion-activatable': true\n      }) }, h(\"a\", Object.assign({}, attrs), h(\"slot\", null))));\n  }\n};\nRouterLink.style = routerLinkCss;\n\nexport { Route as ion_route, RouteRedirect as ion_route_redirect, Router as ion_router, RouterLink as ion_router_link };\n","const hostContext = (selector, el) => {\n  return el.closest(selector) !== null;\n};\n/**\n * Create the mode and color classes for the component based on the classes passed in\n */\nconst createColorClasses = (color, cssClassMap) => {\n  return (typeof color === 'string' && color.length > 0) ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;\n};\nconst getClassList = (classes) => {\n  if (classes !== undefined) {\n    const array = Array.isArray(classes) ? classes : classes.split(' ');\n    return array\n      .filter(c => c != null)\n      .map(c => c.trim())\n      .filter(c => c !== '');\n  }\n  return [];\n};\nconst getClassMap = (classes) => {\n  const map = {};\n  getClassList(classes).forEach(c => map[c] = true);\n  return map;\n};\nconst SCHEME = /^[a-z][a-z0-9+\\-.]*:/;\nconst openURL = async (url, ev, direction, animation) => {\n  if (url != null && url[0] !== '#' && !SCHEME.test(url)) {\n    const router = document.querySelector('ion-router');\n    if (router) {\n      if (ev != null) {\n        ev.preventDefault();\n      }\n      return router.push(url, direction, animation);\n    }\n  }\n  return false;\n};\n\nexport { createColorClasses as c, getClassMap as g, hostContext as h, openURL as o };\n"],"sourceRoot":""}